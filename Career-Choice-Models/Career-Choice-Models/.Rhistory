rename_with(
.fn = function(x){paste0(x,'.input')}
) %>%
bind_cols(
df_occupations
) %>%
# group_by(Occupation) %>%
# mutate(
#   across(
#     .cols = c(
#       !ends_with('.input')
#       , -Occupation
#       , -Career_Cluster
#     )
#     ,.fns = function(x){
#
#       ifelse(
#         x == 0
#         , yes = 0
#         , no = eval(sym(paste0(cur_column(),'.input')))
#       )
#
#     }
#     , .names = '{col}.sub'
#   )
# ) %>%
# ungroup() %>%
select(
ends_with('.input')
) %>%
rename_with(
function(x){str_remove(x,'.input')}
) -> df_input.sub
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub
# SCORE ITEMS (OCCUPATIONS) -----------------------------------------------
psych::scoreVeryFast(
keys = flatten(list_factors)
, items = df_occupations %>%
select(
all_of(
list_factors %>%
flatten() %>%
flatten_chr()
)
)
, totals = F #Average scores
) %>%
as_tibble() %>%
bind_cols(
df_occupations
) %>%
select(
where(
negate(is.numeric)
)
, list_factors %>%
flatten() %>%
names()
) -> df_occupations.scores
# SCORE ITEMS (JSON INPUT) -----------------------------------------------
lapply(
list_factors
, function(scales){
psych::scoreVeryFast(
keys = scales
, items = df_input.sub
, totals = F #Average scores
) %>%
as_tibble()
}
) %>% flatten_df() -> df_factor.scores
# KNN MATCHING WITH ITEM SCORES -------------------------------------------
lapply(
1:nrow(df_factor.scores)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations.scores[x,]
, .vec_query.numeric = df_factor.scores[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub.scores
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# CHEAP QUICK FIX (SUBTITUTE FOR L2-NORM)
# , Euclidean_Distance = min(Euclidean_Distance, 2)
# SUPER CHEAP FIX
, Euclidean_Distance = min(Euclidean_Distance, 1)
, Similarity.Trick = 1 - Euclidean_Distance
# # Common similarity: 1/(1 + dist), "+1" for dist = 0
# , Similarity.Common = 1 / (1 + Euclidean_Distance)
# # Similarity via gaussian kernel: exp(-dist)
# , Similarity.Gaussian = exp(-Euclidean_Distance)
#
# # Square root similarity
# , Similarity.Sqrt = 1 - (sqrt(Euclidean_Distance)/2)
#
# # [Try again] Yielding negative values for greater distances
# # Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# # , Similarity.Tan = 1 - atan(Euclidean_Distance)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
#
# # [Try again] Equivalence between euclidean and cosine
# # [Wrong formula] Yielding negative values for greater distances
# # , Similarity.Cosine = 1 - (Euclidean_Distance/2)
# , Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
#
# # Angular similarity
# , Similarity.Angular = 1 - (acos(Similarity.Cosine)/pi)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# CHEAP QUICK FIX (SUBTITUTE FOR L2-NORM)
# , Euclidean_Distance = min(Euclidean_Distance, 2)
# SUPER CHEAP FIX
, Euclidean_Distance = min(Euclidean_Distance, rep(1,nrow()))
, Similarity.Trick = 1 - Euclidean_Distance
# # Common similarity: 1/(1 + dist), "+1" for dist = 0
# , Similarity.Common = 1 / (1 + Euclidean_Distance)
# # Similarity via gaussian kernel: exp(-dist)
# , Similarity.Gaussian = exp(-Euclidean_Distance)
#
# # Square root similarity
# , Similarity.Sqrt = 1 - (sqrt(Euclidean_Distance)/2)
#
# # [Try again] Yielding negative values for greater distances
# # Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# # , Similarity.Tan = 1 - atan(Euclidean_Distance)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
#
# # [Try again] Equivalence between euclidean and cosine
# # [Wrong formula] Yielding negative values for greater distances
# # , Similarity.Cosine = 1 - (Euclidean_Distance/2)
# , Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
#
# # Angular similarity
# , Similarity.Angular = 1 - (acos(Similarity.Cosine)/pi)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# CHEAP QUICK FIX (SUBTITUTE FOR L2-NORM)
# , Euclidean_Distance = min(Euclidean_Distance, 2)
# SUPER CHEAP FIX
, Euclidean_Distance = min(Euclidean_Distance, rep(1,nrow(.df_data.numeric)))
, Similarity.Trick = 1 - Euclidean_Distance
# # Common similarity: 1/(1 + dist), "+1" for dist = 0
# , Similarity.Common = 1 / (1 + Euclidean_Distance)
# # Similarity via gaussian kernel: exp(-dist)
# , Similarity.Gaussian = exp(-Euclidean_Distance)
#
# # Square root similarity
# , Similarity.Sqrt = 1 - (sqrt(Euclidean_Distance)/2)
#
# # [Try again] Yielding negative values for greater distances
# # Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# # , Similarity.Tan = 1 - atan(Euclidean_Distance)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# # , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
#
# # [Try again] Equivalence between euclidean and cosine
# # [Wrong formula] Yielding negative values for greater distances
# # , Similarity.Cosine = 1 - (Euclidean_Distance/2)
# , Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
#
# # Angular similarity
# , Similarity.Angular = 1 - (acos(Similarity.Cosine)/pi)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
atan(pi)
atan(pi/2)
1 == atan(pi/2)
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# CHEAP QUICK FIX (SUBTITUTE FOR L2-NORM)
, Euclidean_Distance = min(Euclidean_Distance, 2)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# Square root similarity
, Similarity.Sqrt = 1 - (sqrt(Euclidean_Distance)/2)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# Equivalence between euclidean and cosine (if euclidean E [0,2])
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
# Angular similarity
, Similarity.Angular = 1 - (acos(Similarity.Cosine)/pi)
) %>%
return(.)
}
# [REALLY BAD] [INPUT NOTHING] -------------------------------------------------
df_input %>%
rename_with(
.fn = function(x){paste0(x,'.input')}
) %>%
bind_cols(
df_occupations
) %>%
# group_by(Occupation) %>%
# mutate(
#   across(
#     .cols = c(
#       !ends_with('.input')
#       , -Occupation
#       , -Career_Cluster
#     )
#     ,.fns = function(x){
#
#       ifelse(
#         x == 0
#         , yes = 0
#         , no = eval(sym(paste0(cur_column(),'.input')))
#       )
#
#     }
#     , .names = '{col}.sub'
#   )
# ) %>%
# ungroup() %>%
select(
ends_with('.input')
) %>%
rename_with(
function(x){str_remove(x,'.input')}
) -> df_input.sub
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub
# SCORE ITEMS (OCCUPATIONS) -----------------------------------------------
psych::scoreVeryFast(
keys = flatten(list_factors)
, items = df_occupations %>%
select(
all_of(
list_factors %>%
flatten() %>%
flatten_chr()
)
)
, totals = F #Average scores
) %>%
as_tibble() %>%
bind_cols(
df_occupations
) %>%
select(
where(
negate(is.numeric)
)
, list_factors %>%
flatten() %>%
names()
) -> df_occupations.scores
# SCORE ITEMS (JSON INPUT) -----------------------------------------------
lapply(
list_factors
, function(scales){
psych::scoreVeryFast(
keys = scales
, items = df_input.sub
, totals = F #Average scores
) %>%
as_tibble()
}
) %>% flatten_df() -> df_factor.scores
# KNN MATCHING WITH ITEM SCORES -------------------------------------------
lapply(
1:nrow(df_factor.scores)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations.scores[x,]
, .vec_query.numeric = df_factor.scores[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Euclidean_Distance)) -> df_KNN.output.sub.scores
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
