)
, totals = F #Average scores
) %>%
as_tibble() %>%
bind_cols(
df_occupations
) %>%
select(
where(
negate(is.numeric)
)
, list_factors %>%
flatten() %>%
names()
) -> df_occupations.scores
# SCORE ITEMS (JSON INPUT) -----------------------------------------------
lapply(
list_factors
, function(scales){
psych::scoreVeryFast(
keys = scales
, items = df_input.sub
, totals = F #Average scores
) %>%
as_tibble()
}
) %>% flatten_df() -> df_factor.scores
# KNN MATCHING WITH ITEM SCORES -------------------------------------------
lapply(
1:nrow(df_factor.scores)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations.scores[x,]
, .vec_query.numeric = df_factor.scores[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Similarity.Common)) -> df_KNN.output.sub.scores
# OUTPUT ------------------------------------------------------------------
# df_KNN.output.sub %>%
#   select(
#     Occupation
#     , Career_Cluster
#     , Euclidean_Distance
#     , starts_with('Similarity')
#   ) %>%
#   view()
df_KNN.output.sub.scores %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Similarity.Common)) -> df_KNN.output.sub
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
) %>%
group_by(where(negate(is.numeric))) %>%
# CHEAP QUICK FIX
mutate(
Euclidean_Distance = min(Euclidean_Distance, 2)
# , Euclidean_Distance = min(Euclidean_Distance, 1)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Similarity.Common)) -> df_KNN.output.sub
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
) %>%
group_by(across(where(negate(is.numeric)))) %>%
# CHEAP QUICK FIX
mutate(
Euclidean_Distance = min(Euclidean_Distance, 2)
# , Euclidean_Distance = min(Euclidean_Distance, 1)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Similarity.Common)) -> df_KNN.output.sub
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# # CHEAP QUICK FIX
# # , Euclidean_Distance = min(Euclidean_Distance, 2)
# , Euclidean_Distance = min(Euclidean_Distance, 1)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
) %>%
return(.)
}
# KNN MATCHING WITHOUT ITEM SCORES ----------------------------------------
lapply(
1:nrow(df_input.sub)
, function(x){
fun_KNN.matching(
.df_data.numeric = df_occupations[x,]
, .vec_query.numeric = df_input.sub[x,]
, .int_k = 1
)
}) %>%
bind_rows() %>%
arrange(desc(Similarity.Common)) -> df_KNN.output.sub
# OUTPUT ------------------------------------------------------------------
df_KNN.output.sub %>%
select(
Occupation
, Career_Cluster
, Euclidean_Distance
, starts_with('Similarity')
) %>%
view()
?norm()
df_input
df_input.sub
df_input.sub %>% rowwise() %>% norm(type = '2')
df_input.sub %>% norm(type = '2')
?scale()
df_input.sub %>% norm(type = '2')
df_input.sub[,1] %>% norm(type = '2')
df_input.sub[1,] %>% norm(type = '2')
df_input.sub[1,]/norm(df_input.sub[1,],type = '2')
df_input.sub[1,]/norm(as.numeric(df_input.sub[1,])),type = '2')
as.numeric(df_input.sub[1,])
as.numeric(df_input.sub[1,]) %>% norm(type = '2')
as.numeric(df_input.sub[1,]) %>% norm(type = '2') -> ds
df_input.sub[1,]/ds
df_input.sub[1,]/ds %>% as_tibble()
(df_input.sub[1,]/ds) %>% tibble()
(df_input.sub[1,]/ds) %>% tibble() %>% view()
df_occupations
df_factor.scores
df_factor.scores[1,]
df_factor.scores[1,] %>% norm(type = '2')
df_factor.scores[1,] %>% norm(type = '2') -> ds
df_factor.scores[1,]/ds
df_factor.scores[1,]/ds %>% view()
(df_factor.scores[1,]/ds) %>% view()
df_occupations.scores
df_occupations.scores[1.]
df_occupations.scores[1,]
df_occupations.scores[1,] %>% norm(type = '2')
df_occupations.scores[1,] %>% norm(type = '2')
df_occupations.scores[1,]
df_occupations.scores[1,3:]
df_occupations.scores[1,3:ncol(.)]
df_occupations.scores[1,3:ncol(df_occupations.scores)]
df_occupations.scores[1,3:ncol(df_occupations.scores)] %>% norm(type = '2')
df_occupations.scores[1,3:ncol(df_occupations.scores)] %>% norm(type = '2') -> dsds
df_occupations.scores[1,3:ncol(df_occupations.scores)]
df_occupations.scores[1,3:ncol(df_occupations.scores)]/dsds
df_occupations.scores[1,3:ncol(df_occupations.scores)]/dsds -> lalala
knnx.dist(data = lalala, query = df_factor.scores/ds)
df_factor.scores
knnx.dist(data = lalala, query = df_factor.scores[1,]/ds)
df_factor.scores[1,]
df_factor.scores[1,]/ds
df_factor.scores[1,]/ds -> lala
lalala
lala
class(lalala)
ncol(lalala)
ncol(lala)
knnx.dist(data = lalala, query = lala, k = 1)
1 - knnx.dist(data = lalala, query = lala, k = 1)
knnx.dist(data = lalala, query = lala, k = 1)
1 - ((0.6326184^2)/2)
knorm
?knorm
# KNN MATCHING FUNCTION (WITH L2 NORMALIZATION) -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
# Euclidean normalization (L2 norm)
.df_data.numeric.temp %>%
rowwise() %>%
mutate(
across(
.cols = everything()
,.fns = function(x){x/norm(x, type = '2')}
)
) %>%
ungroup() -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
rowwise() %>%
mutate(
across(
.cols = everything()
,.fns = function(x){x/norm(x, type = '2')}
)
) %>%
ungroup() -> .vec_query.numeric
} else {
.vec_query.numeric <- .vec_query.numeric / norm(.vec_query.numeric, type = '2')
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# # CHEAP QUICK FIX
# # , Euclidean_Distance = min(Euclidean_Distance, 2)
# , Euclidean_Distance = min(Euclidean_Distance, 1)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
) %>%
return(.)
}
# KNN MATCHING FUNCTION (WITH L2 NORMALIZATION) -------------------------------------------------------------------------
fun_KNN.matching <- function(
.df_data.numeric
, .vec_query.numeric
, .int_k = 1
, .auto_select.k = F
, .normalize.euclidean = T
){
# Get numeric data only
.df_data.numeric %>%
select(where(is.numeric)) -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
select(where(is.numeric)) -> .vec_query.numeric
}
if(.normalize.euclidean){
# Euclidean normalization (L2 norm)
.df_data.numeric.temp %>%
rowwise() %>%
mutate(
across(
.cols = everything()
,.fns = function(x){x/norm(x, type = '2')}
)
) %>%
ungroup() -> .df_data.numeric.temp
if(is.data.frame(.vec_query.numeric)){
.vec_query.numeric %>%
rowwise() %>%
mutate(
across(
.cols = everything()
,.fns = function(x){x/norm(x, type = '2')}
)
) %>%
ungroup() -> .vec_query.numeric
} else {
.vec_query.numeric <- .vec_query.numeric / norm(.vec_query.numeric, type = '2')
}
}
# Define k
if(.auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
.df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> .int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = .df_data.numeric.temp
, query = .vec_query.numeric
, k = .int_k
) -> KNN.output
# Arrange original data frame with KNN output
.df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# # CHEAP QUICK FIX
# # , Euclidean_Distance = min(Euclidean_Distance, 2)
# , Euclidean_Distance = min(Euclidean_Distance, 1)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
, Similarity.Cosine = 1 - ((Euclidean_Distance^2)/2)
) %>%
return(.)
}
