, 'shiny' #Shiny app
,'lubridate' ,'tidyverse' #Manipulação de dados e datas
)
# Ativa e/ou instala os pacotes
lapply(pkg, function(x)
if(!require(x, character.only = T))
{install.packages(x); require(x)})
# Citação dos pacotes
# lapply(pkg, function(x)
#   {citation(package = x)})
# SERVER FUNCTION -------------------------------------------------------------------
dsds <- function(
input
){
qplot(input)
}
# PACOTES -----------------------------------------------------------------
# pkg <- c(
#   'ggthemes', 'scales' #Visualização
#   , 'shiny' #Shiny app
#   ,'lubridate' ,'tidyverse' #Manipulação de dados e datas
# )
#
# # Ativa e/ou instala os pacotes
# lapply(pkg, function(x)
#   if(!require(x, character.only = T))
#   {install.packages(x); require(x)})
#
# # Citação dos pacotes
# # lapply(pkg, function(x)
# #   {citation(package = x)})
# CALL UI & SERVER ------------------------------------------------------------------
# Call UI
source('C:/Users/Cao/Documents/Github/Count-The-Cost/UI.R')
# Call server
source('C:/Users/Cao/Documents/Github/Count-The-Cost/server.R')
shinyApp(ui = lalala, server = dsds)
# CALL UI & SERVER ------------------------------------------------------------------
# Call UI
source('C:/Users/Cao/Documents/Github/Count-The-Cost/UI.R')
# Call server
source('C:/Users/Cao/Documents/Github/Count-The-Cost/server.R')
# EXECUTE SHINY APP -------------------------------------------------------
shinyApp(ui = lalala, server = dsds)
# PACOTES -----------------------------------------------------------------
# pkg <- c(
#   'ggthemes', 'scales' #Visualização
#   , 'shiny' #Shiny app
#   ,'lubridate' ,'tidyverse' #Manipulação de dados e datas
# )
#
# # Ativa e/ou instala os pacotes
# lapply(pkg, function(x)
#   if(!require(x, character.only = T))
#   {install.packages(x); require(x)})
#
# # Citação dos pacotes
# # lapply(pkg, function(x)
# #   {citation(package = x)})
# CALL UI & SERVER ------------------------------------------------------------------
# Call UI
source('C:/Users/Cao/Documents/Github/Count-The-Cost/UI.R')
# Call server
source('C:/Users/Cao/Documents/Github/Count-The-Cost/server.R')
# EXECUTE SHINY APP -------------------------------------------------------
shinyApp(ui = lalala, server = dsds)
# EXECUTE SHINY APP -------------------------------------------------------
shinyApp(ui = lalala, server = dsds)
library(shiny)
library(shiny)
shiny::runExample('02_text')
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Shiny Text"),
# Sidebar layout with a input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Selector for choosing dataset ----
selectInput(inputId = "dataset",
label = "Choose a dataset:",
choices = c("rock", "pressure", "cars")),
# Input: Numeric entry for number of obs to view ----
numericInput(inputId = "obs",
label = "Number of observations to view:",
min = 0,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Verbatim text for data summary ----
verbatimTextOutput("summary"),
# Output: HTML table with requested number of observations ----
tableOutput("view")
)
)
)
library(shiny)
library(shiny)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Shiny Text"),
# Sidebar layout with a input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Selector for choosing dataset ----
selectInput(inputId = "dataset",
label = "Choose a dataset:",
choices = c("rock", "pressure", "cars")),
# Input: Numeric entry for number of obs to view ----
numericInput(inputId = "obs",
label = "Number of observations to view:",
min = 0,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Verbatim text for data summary ----
verbatimTextOutput("summary"),
# Output: HTML table with requested number of observations ----
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
# Return the requested dataset ----
datasetInput <- reactive({
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
})
# Generate a summary of the dataset ----
output$summary <- renderPrint({
dataset <- datasetInput()
summary(dataset)
})
# Show the first "n" observations ----
output$view <- renderTable({
head(datasetInput(), n = input$obs)
})
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Shiny Text"),
# Sidebar layout with a input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Selector for choosing dataset ----
checkboxGroupInput(inputId = "dataset",
label = "Choose a dataset:",
choices = c("rock", "pressure", "cars")),
# selectInput(inputId = "dataset",
#             label = "Choose a dataset:",
#             choices = c("rock", "pressure", "cars")),
#
# Input: Numeric entry for number of obs to view ----
numericInput(inputId = "obs",
label = "Number of observations to view:",
min = 0,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Verbatim text for data summary ----
verbatimTextOutput("summary"),
# Output: HTML table with requested number of observations ----
tableOutput("view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
# Return the requested dataset ----
datasetInput <- reactive({
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
})
# Generate a summary of the dataset ----
output$summary <- renderPrint({
dataset <- datasetInput()
summary(dataset)
})
# Show the first "n" observations ----
output$view <- renderTable({
head(datasetInput(), n = input$obs)
})
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Shiny Text"),
# Sidebar layout with a input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Selector for choosing dataset ----
checkboxGroupInput(inputId = "dataset",
label = "Choose a dataset:",
choices = c("rock", "pressure", "cars")),
# selectInput(inputId = "dataset",
#             label = "Choose a dataset:",
#             choices = c("rock", "pressure", "cars")),
#
# Input: Numeric entry for number of obs to view ----
numericInput(inputId = "obs",
label = "Number of observations to view:",
min = 0,
value = 10)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Verbatim text for data summary ----
verbatimTextOutput(outputId = "dsdsds"),
# Output: HTML table with requested number of observations ----
tableOutput(outputId = "view")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
# Return the requested dataset ----
datasetInput <- reactive({
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
})
# Generate a summary of the dataset ----
output$dsdsds <- renderPrint({
dataset <- datasetInput()
summary(dataset)
})
# Show the first "n" observations ----
output$view <- renderTable({
head(datasetInput(), n = input$obs)
})
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)
pkg <- c(
# 'ggthemes', 'scales' #Visualization
'tidyverse' #Data wrangling
)
# Activate / install packages
lapply(pkg, function(x)
if(!require(x, character.only = T))
{install.packages(x); require(x)})
# Output
EFA.5$adequacy.tests
# PACKAGES -----------------------------------------------------------------
pkg <- c(
'tidyverse' #Data wrangling
, 'FNN' #Fast K-NN Algorithm (faster than the 'class' package)
)
# Activate / install packages
lapply(pkg, function(x)
if(!require(x, character.only = T))
{install.packages(x); require(x)})
# Package citation
# lapply(pkg, function(x)
#   {citation(package = x)})
# KNN MATCHING FUNCTION -------------------------------------------------------------------------
fun_KNN.matching <- function(
df_data.numeric
, vec_query.numeric
, int_k = 1
, auto_select.k = F
){
# Get numeric data only
df_data.numeric %>%
select(where(is.numeric)) -> df_data.numeric.temp
# Define k
if(auto_select.k){
# RECOMMENDED
# Typical suggested value for k is sqrt(nrow(df))
# Looking for k nearest neighbors in all career clusters
df_data.numeric %>%
nrow(.) %>%
sqrt(.) %>%
round(.) -> int_k
}
# Find the k nearest neighbors
FNN::get.knnx(
data = df_data.numeric.temp
, query = vec_query.numeric
, k = int_k
) -> KNN.output
# Arrange original data frame with KNN output
df_data.numeric %>%
slice(as.vector(KNN.output$nn.index)) %>%
mutate(#Add euclidean distances and convert them to similarities
Euclidean_Distance = as.vector(KNN.output$nn.dist)
# Common similarity: 1/(1 + dist), "+1" for dist = 0
, Similarity.Common = 1 / (1 + Euclidean_Distance)
# Similarity via gaussian kernel: exp(-dist)
, Similarity.Gaussian = exp(-Euclidean_Distance)
# [Try again] Yielding negative values for greater distances
# Tangent similarity: 1 - arctan(dist) = 1 for dist = 0
# , Similarity.Tan = 1 - atan(Euclidean_Distance)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/2)
# , Similarity.Tan = 1 - atan(Euclidean_Distance/pi)
# [Try again] Equivalence between euclidean and cosine
# [Wrong formula] Yielding negative values for greater distances
# , Similarity.Cosine = 1 - (Euclidean_Distance/2)
# , Similarity.Cosine = 1 - (Euclidean_Distance^2)/2
) %>%
return(.)
}
# EFA-REDUCED OCCUPATIONS DATA FRAME -------------------------------------------
# Occupations data frame
df_occupations <- readr::read_csv('https://docs.google.com/spreadsheets/d/e/2PACX-1vSphzWoCxoNaiaJcQUWKCMqUAT041Q8UqUgM7rSzIwYZb7FhttKJwNgtrFf-r7EgzXHFom4UjLl2ltk/pub?gid=563902602&single=true&output=csv')
# Selected skills, abilities and knowledge
c(
# Factor 1 is composed of cognitive, non-technical, general skills (general competencies)
'Judgment_and_Decision.L'
, 'Complex_Problem_Solving.L'
, 'Active_Learning.L'
, 'Critical_Thinking.L'
# Factor 2 is composed of mechanical, hands-on, specialist skills (technical)
, 'Equipment_Selection.L'
, 'Troubleshooting.L'
, 'Repairing.L'
, 'Equipment_Maintenance.L'
) -> chr_Skill.Items
c(
# Factor 1 is composed of perceptual abilities (perception):
'Night_Vision.L'
, 'Sound_Localization.L'
, 'Glare_Sensitivity.L'
# Factor 2 is composed of manual abilities (dexterity):
, 'Finger_Dexterity.L'
, 'Arm_Hand_Steadiness.L'
, 'Manual_Dexterity.L'
# Factor 3 is composed of bodily robustness, potency, and coordination (overall
, 'Stamina.L'
, 'Gross_Body_Coordination.L'
, 'Trunk_Strength.L'
# Factor 4 is composed of cognitive abilities (intelligence):
, 'Inductive_Reasoning.L'
, 'Problem_Sensitivity.L'
, 'Deductive_Reasoning.L'
) -> chr_Ablt.Items
c(
# Factor 1 is composed of health-related fields of knowledge (health / help).
'Therapy_and_Counseling.L'
, 'Psychology.L'
, 'Medicine_and_Dentistry.L'
# Factor 2 is composed of engineering / building-related fields of knowledge (build).
, 'Physics.L'
, 'Engineering_and_Technology.L'
, 'Building_and_Construction.L'
# Factor 3 is composed of financial and enterprising fields of knowledge (FGV).
, 'Economics_and_Accounting.L'
, 'Sales_and_Marketing.L'
, 'Administration_and_Management.L'
# Factor 4 is composed of arts and humanities (communists).
, 'History_and_Archeology.L'
, 'Geography.L'
, 'Fine_Arts.L'
) -> chr_Know.Items
# Matching data frame
df_occupations %>%
select(
where(
negate(is.numeric)
)
, all_of(c(
chr_Skill.Items
, chr_Ablt.Items
# , chr_Know.Items
))
) %>%
mutate(
across(
.cols = all_of(c(
chr_Skill.Items
, chr_Ablt.Items
# , chr_Know.Items
))
,.fns = function(x){x/100}
)
) -> df_occupations
# QUERY VECTOR (USER INPUT) -----------------------------------------------
# Simulate one user input
source('C:/Users/Cao/Documents/Github/Atlas-Research/Career-Choice-Models/Simulated_Data.R')
fun_simulate.tmvnorm(
df_data.numeric = df_occupations
, int_n.simulations = 1
) -> vec_user.input
# APPLY KNN ---------------------------------------------------------------
fun_KNN.matching(
df_data.numeric = df_occupations
, vec_query.numeric = vec_user.input
, int_k = nrow(df_occupations)
) -> df_KNN.output
# PACKAGES -----------------------------------------------------------------
pkg <- c(
'tidyverse' #Data wrangling
, 'FNN' #Fast K-NN Algorithm (faster than the 'class' package)
)
# Activate / install packages
lapply(pkg, function(x)
if(!require(x, character.only = T))
{install.packages(x); require(x)})
# Package citation
# lapply(pkg, function(x)
#   {citation(package = x)})
# WORKING DIRECTORY -------------------------------------------------------
setwd('C:/Users/Cao/Documents/Github/Atlas-Research/Career-Choice-Models')
# FUNCTIONS ---------------------------------------------------------------
source('./Simulated_Data.R')
source('./KNN_Matching.R')
# EFA-REDUCED OCCUPATIONS DATA FRAME -------------------------------------------
# Occupations data frame
df_occupations <- readr::read_csv('https://docs.google.com/spreadsheets/d/e/2PACX-1vSphzWoCxoNaiaJcQUWKCMqUAT041Q8UqUgM7rSzIwYZb7FhttKJwNgtrFf-r7EgzXHFom4UjLl2ltk/pub?gid=563902602&single=true&output=csv')
# Selected skills, abilities and knowledge
c(
# Factor 1 is composed of cognitive, non-technical, general skills (general competencies)
'Judgment_and_Decision.L'
, 'Complex_Problem_Solving.L'
, 'Active_Learning.L'
, 'Critical_Thinking.L'
# Factor 2 is composed of mechanical, hands-on, specialist skills (technical)
, 'Equipment_Selection.L'
, 'Troubleshooting.L'
, 'Repairing.L'
, 'Equipment_Maintenance.L'
) -> chr_Skill.Items
c(
# Factor 1 is composed of perceptual abilities (perception):
'Night_Vision.L'
, 'Sound_Localization.L'
, 'Glare_Sensitivity.L'
# Factor 2 is composed of manual abilities (dexterity):
, 'Finger_Dexterity.L'
, 'Arm_Hand_Steadiness.L'
, 'Manual_Dexterity.L'
# Factor 3 is composed of bodily robustness, potency, and coordination (overall
, 'Stamina.L'
, 'Gross_Body_Coordination.L'
, 'Trunk_Strength.L'
# Factor 4 is composed of cognitive abilities (intelligence):
, 'Inductive_Reasoning.L'
, 'Problem_Sensitivity.L'
, 'Deductive_Reasoning.L'
) -> chr_Ablt.Items
c(
# Factor 1 is composed of health-related fields of knowledge (health / help).
'Therapy_and_Counseling.L'
, 'Psychology.L'
, 'Medicine_and_Dentistry.L'
# Factor 2 is composed of engineering / building-related fields of knowledge (build).
, 'Physics.L'
, 'Engineering_and_Technology.L'
, 'Building_and_Construction.L'
# Factor 3 is composed of financial and enterprising fields of knowledge (FGV).
, 'Economics_and_Accounting.L'
, 'Sales_and_Marketing.L'
, 'Administration_and_Management.L'
# Factor 4 is composed of arts and humanities (communists).
, 'History_and_Archeology.L'
, 'Geography.L'
, 'Fine_Arts.L'
) -> chr_Know.Items
# Matching data frame
df_occupations %>%
select(
where(
negate(is.numeric)
)
, all_of(c(
chr_Skill.Items
, chr_Ablt.Items
# , chr_Know.Items
))
) %>%
mutate(
across(
.cols = all_of(c(
chr_Skill.Items
, chr_Ablt.Items
# , chr_Know.Items
))
,.fns = function(x){x/100}
)
) -> df_occupations
# QUERY VECTOR (USER INPUT) -----------------------------------------------
# Simulate one user input
fun_simulate.tmvnorm(
df_data.numeric = df_occupations
, int_n.simulations = 1
) -> vec_user.input
# APPLY KNN ---------------------------------------------------------------
fun_KNN.matching(
df_data.numeric = df_occupations
, vec_query.numeric = vec_user.input
, int_k = nrow(df_occupations)
) -> df_KNN.output
df_KNN.output
