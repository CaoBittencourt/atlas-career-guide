mutate(
factors.tally = as.numeric(factors.tally)
, factors.interval =
findInterval(
factors.tally
, factors.tally
)
, interval =
findInterval(
x = list_text$bot_match.underqualified.n
, vec = factors.tally
)
, .before = 1
) %>%
filter(
factors.interval == interval
) %>%
pull(text) -> list_text$bot_match.underqualified
# Bot match overqualification analysis
if(
list_df.text$bot_match.overqualified %>%
pull(factors.tally) %>%
as.numeric() %>%
max(na.rm = T) <= 2
){
list_df.text$bot_match.overqualified %>%
filter(as.numeric(factors.tally) <= 2)
} else {
list_df.text$bot_match.overqualified %>%
mutate(
factors.tally =
map_dbl(
factors.tally
, ~ eval(parse(text = .x))
))
} %>%
mutate(
factors.interval =
findInterval(
factors.tally
, factors.tally
)
, interval =
findInterval(
x = list_text$bot_match.overqualified.n
, vec = factors.tally
)
, .before = 1
) %>%
filter(
factors.interval == interval
) %>%
pull(text) -> list_text$bot_match.overqualified
# Bot match common strengths analysis
list_df.text$bot_match.strengths.common %>%
filter(
factors.tally == list_text$bot_match.strengths.common.n
) %>%
pull(text) -> list_text$bot_match.strengths.common
# Capacity analysis
map(
list(
'top_match.capacity' = list_text$top_match.overqualified.n
, 'bot_match.capacity' = list_text$bot_match.overqualified.n
)
, ~
list_df.text$capacity %>%
mutate(
pct.over = .x / list_text$nfactors
, n.interval =
pct.over %>%
round(1) %>%
findInterval(vec = seq_scale.1_5)
) %>%
filter(interval == n.interval) %>%
slice(1) %>%
pull(text)
) %>%
c(list_text) -> list_text
list_df.text$capacity.same %>%
mutate(
'same' =
list_text$top_match.overqualified.n ==
list_text$bot_match.overqualified.n
) %>%
filter(
overqualified.same == same
) %>%
pull(text) -> list_text$top_bot_match.capacity.same
# Apply remaining textual input
map(
list_df.text
, ~ fun_text.dynamic(.x, list_text)
) -> list_df.text
list_df.text$sections %>%
mutate(text = ifelse(
section == 'date'
, format(Sys.Date(), text)
, text
)) -> list_df.text$sections
# Text list
as.list(list_df.text$sections$text) -> list_report.texts
# Section titles
list_df.text$sections.title %>%
mutate(title = paste(strrep('#', level), title)) %>%
pull(title) %>%
as.list() -> list_report.titles
# Captions
list_df.text$plots %>%
pull(plot.caption) %>%
unique() %>%
as.list() -> list_plots.caption
# Text elements
list_df.text$text.elements %>%
pull(title) %>%
as.list() -> list_text.elements
# -------- TABLES ---------------------------------------------------------
# TOP 7, BOTTOM 3 MATCHES -----------------------------------------
# Table of Top 7 Bottom 3 Matches
df_KNN.output %>%
slice(1:7, seq(max(rank) - 2, max(rank))) %>%
mutate(
similarity = percent(similarity, accuracy = .01)
, annual_wage_2021 = dollar(
annual_wage_2021, accuracy = .01
# annual_wage_2021, accuracy = 1, prefix = 'U$ '
# annual_wage_2021, accuracy = 1, prefix = 'USD '
)
) %>%
select(
rank
, occupation
, annual_wage_2021
, similarity
) -> df_top7.bot3
list_df.text$matching.table %>%
pull(text) -> names(df_top7.bot3)
# -------- PLOTS ----------------------------------------------------------
# [CIRCULAR BAR PLOT] MATCHING PERCENTAGES -----------------------------------------------------
df_KNN.output %>%
mutate(
recommended = ifelse(
round(similarity, 2) >= dbl_recommended.cutff
| is.na(similarity)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
nth(1)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
nth(2)
)
) %>%
fun_plot.bar(aes(
x = rank
, y = similarity
, fill = recommended
)
, .theme = theme_ridges(center_axis_labels = T) +
theme(
title = element_text(hjust = 0.5)
, plot.title.position = 'plot'
, legend.position = 'bottom'
, legend.justification = 'center'
, legend.key.size = unit(0.5,'cm')
, legend.key.width = unit(2,'cm')
# , plot.margin = margin(1, 1, 1, 1,'cm')
, plot.margin = margin(0, 0, 0, 0,'cm')
)
, .fun_format.y = function(x){percent(x,accuracy = 1)}
, .coord_polar = T
, .fun_polar.labels = percent
, .list_axis.y.args = list(
breaks = seq(0, 1, length.out = 5)
)
, .list_geom.param = list(
position = c(position_dodge2(0.5, 'single'))
, width = 0.5
)
, .list_labels.param = list(
color = list_pal.atlas$black
)
, .chr_manual.pal = setNames(
c(
list_pal.atlas$purple3
, list_pal.atlas$grey
)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
unique()
)
, .chr_manual.aes = c(
'fill', 'color'
)
, .list_legend = list(
color = 'none'
)
, .list_labs = list(
y =
list_df.text$plots %>%
filter(order == unique(order)[1]) %>%
pull(plot.y) %>%
unique()
, fill = NULL
)) -> plt_match.polar
# [LINE CHART] PROFESSIONAL COMPATIBILITY CURVE -------------------------------------------------------------------
df_KNN.output %>%
fun_plot.line(aes(
x = rank.norm
, y = similarity
, color = similarity >= dbl_recommended.cutff
)
, .dbl_limits.y = c(0,1)
, .chr_manual.pal = c(
list_pal.atlas$grey
, list_pal.atlas$purple3
)
, .list_legend = list(color = 'none')
, .fun_format.y = label_percent()
, .reorder_fct = F
, .reorder_desc = F
, .theme = ggridges::theme_ridges(font_size = 11, center_axis_labels = T) +
theme(
plot.margin = margin(0, 0, 0, 0)
, axis.text.x = element_blank()
, axis.text.y = element_text(vjust = 0.5)
)
, .list_labs = list(
title = NULL
, subtitle = NULL
, x =
list_df.text$plots %>%
filter(order == unique(order)[2]) %>%
pull(plot.x)
, y =
list_df.text$plots %>%
filter(order == unique(order)[2]) %>%
pull(plot.y)
)) +
geom_segment(
x = 0
# , xend = 1 - list_df.matches$bot_match$similarity
, xend = 1
# , y = list_df.matches$bot_match$similarity
, y = 0
, yend = 1
, linewidth = 0.25
, color = list_pal.atlas$black
, linetype = 2
) -> plt_line.rank
c(
plt_line.rank$layers
, geom_textvline(
xintercept =
(list_text$nrow_occupations - list_text$n_recommended) /
(list_text$nrow_occupations - 1)
, label =
list_df.text$plots %>%
filter(order == unique(order)[2]) %>%
pull(plot.color)
, color = list_pal.atlas$purple3
, fontface = 'bold'
, linetype = 1
, linewidth = 1.35
, hjust = 0.125
, vjust = -0.5
)
) -> plt_line.rank$layers
# [DENSITY] PROFESSIONAL COMPATIBILITY DISTRIBUTION -----------------------
df_KNN.output %>%
fun_plot.histogram(aes(
x = similarity
, y = after_stat(density)
)
, .dbl_limits.y = c(0,1.25*max(density(df_KNN.output$similarity)$y))
, .list_axis.x.args = list(
limits = c(-0.1,1.1)
, breaks = seq(0,1,.25)
)
, .fun_format.x = percent_format(accuracy = 1)
, .list_labs = list(
title = NULL
, subtitle = NULL
, x =
list_df.text$plots %>%
filter(order == unique(order)[3]) %>%
pull(plot.x)
, y = NULL
)
, .theme = ggridges::theme_ridges(font_size = 11, center_axis_labels = T) +
theme(
plot.margin = margin(0, 0, 0, 0)
, axis.text.y = element_blank()
)
) +
geom_density(aes(
x = similarity
)
, size = 1.2
) +
geom_textvline(
xintercept = dbl_recommended.cutff
, label =
list_df.text$plots %>%
filter(order == unique(order)[3]) %>%
pull(plot.color)
, color = list_pal.atlas$green
, fontface = 'bold'
, linetype = 1
, linewidth = 1.35
, hjust = 0.125
, vjust = -0.5
) -> plt_density
# [DUMBBELL PLOT] USER VS TOP MATCH / BOTTOM MATCH ------------------------------------
map(
setNames(
c(
list_text$bot_match.name
, list_text$top_match.name
)
, c('bot_match', 'top_match')
)
, ~
list_factor.scores$scores.long %>%
filter(
id.unique %in% c(list_text$username, .x
)) %>%
mutate(id.unique = fct_inorder(id.unique)) %>%
fun_plot.dumbbell2(aes(
x = factor.score
, y = factor
, color = id.unique
)
, .sym_facets = category
, .int_facets = 1
, .chr_scales = 'free_y'
, .list_labs = list(
title = NULL
, x =
list_df.text$plots %>%
filter(plot.section == 'top_match') %>%
pull(plot.x) %>%
unique()
, y = NULL
, color = NULL
)
, .reorder_fct = T
, .reorder_desc = T
, .chr_manual.pal = set_names(
c(
list_pal.atlas$purple3
, list_pal.atlas$green
, list_pal.atlas$red
)
, c(
list_text$username
, list_text$top_match.name
, list_text$bot_match.name
))
, .list_axis.x.args = list(
limits = c(-0.1, 1.1)
, breaks = seq(0, 1, 0.25)
)
, .fun_format.x = percent_format(accuracy = 1)
, .fun_format.y = function(y){y}
, .theme = theme_ridges(center_axis_labels = T) +
theme(
title = element_text(hjust = 0.5)
, plot.title.position = 'plot'
, legend.position = 'bottom'
, legend.justification = 'center'
, strip.background = element_blank()
, plot.margin = margin(0, 0, 0, 0,'cm')
, axis.text.y = element_text(vjust = 0.5)
))
) -> list_plt.dumbbells
# -------- RENDER -----------------------------------------------------------
# RENDER R MARKDOWN REPORT --------------------------------------------------
rmarkdown::render(
'C:/Users/Cao/Documents/Github/Atlas-Research/Reports/Matching Report/matching_report2.Rmd'
, output_file = paste0('Matching Report (', chr_text.user, ').pdf')
)
# DISTANCE TO SIMILARITY FUNCTION 2 ------------------------------
fun_similarity <- function(
.df_data.numeric
, .dbl_distance
, .dbl_scale.lb = 0
, .dbl_scale.ub = 1
){
.df_data.numeric %>%
select(where(
is.numeric
)) -> .df_data.numeric
.df_data.numeric %>%
slice(
.df_data.numeric %>%
mutate(across(
.cols = everything()
,.fns =
~ if_else(
.x >= mean(c(
.dbl_scale.lb
, .dbl_scale.ub
))
, abs(.x - .dbl_scale.lb)
, abs(.x - .dbl_scale.ub)
)
)) %>%
rowSums() %>%
which.max()
) -> df_dist.max
df_dist.max -> df_dist.max.query
df_dist.max.query[
df_dist.max.query >=
mean(c(
.dbl_scale.lb
, .dbl_scale.ub
))
] <- .dbl_scale.lb
df_dist.max.query[
df_dist.max.query <
mean(c(
.dbl_scale.lb
, .dbl_scale.ub
))
] <- .dbl_scale.ub
FNN::get.knnx(
data = df_dist.max
, query = df_dist.max.query
, k = 1
)$nn.dist %>%
as.numeric() -> dbl_dist.max
# Normalize by the maximum euclidean distance
.dbl_distance <- .dbl_distance / dbl_dist.max
# # Already considered formulae
dbl_similarity <- 1 - .dbl_distance #Bound at [0,1]
return(dbl_similarity)
}
df_KNN.output
# -------- PLOTS ----------------------------------------------------------
# [CIRCULAR BAR PLOT] MATCHING PERCENTAGES -----------------------------------------------------
df_KNN.output %>%
mutate(
recommended = ifelse(
round(similarity, 2) >= dbl_recommended.cutoff
| is.na(similarity)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
nth(1)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
nth(2)
)
) %>%
fun_plot.bar(aes(
x = rank
, y = similarity
, fill = recommended
)
, .theme = theme_ridges(center_axis_labels = T) +
theme(
title = element_text(hjust = 0.5)
, plot.title.position = 'plot'
, legend.position = 'bottom'
, legend.justification = 'center'
, legend.key.size = unit(0.5,'cm')
, legend.key.width = unit(2,'cm')
# , plot.margin = margin(1, 1, 1, 1,'cm')
, plot.margin = margin(0, 0, 0, 0,'cm')
)
, .fun_format.y = function(x){percent(x,accuracy = 1)}
, .coord_polar = T
, .fun_polar.labels = percent
, .list_axis.y.args = list(
breaks = seq(0, 1, length.out = 5)
)
, .list_geom.param = list(
position = c(position_dodge2(0.5, 'single'))
, width = 0.5
)
, .list_labels.param = list(
color = list_pal.atlas$black
)
, .chr_manual.pal = setNames(
c(
list_pal.atlas$purple3
, list_pal.atlas$grey
)
, list_df.text$plots %>%
filter(order == min(order)) %>%
pull(plot.color) %>%
unique()
)
, .chr_manual.aes = c(
'fill', 'color'
)
, .list_legend = list(
color = 'none'
)
, .list_labs = list(
y =
list_df.text$plots %>%
filter(order == unique(order)[1]) %>%
pull(plot.y) %>%
unique()
, fill = NULL
)) -> plt_match.polar
plt_match.polar
